---
title: "Hands-on Exercise 1: Geospatial Data Wrangling with R"
execute: 
  warning: false
date: "`r Sys.Date()`"
---

# Overview

# Getting Started

#### Installing and loading R packages

In this section, I will install and load [*tidyverse*]{.underline} and [*sf*]{.underline} packages.

```{r}
pacman::p_load(tidyverse, sf)
```

# Importing a geospatial data in shapefile format

Next, I will be importing the geospatial data files.

#### Importing Master Plan 2014 Subzone Boundary (Web) files:

```{r}
mpsz <- st_read(dsn = "data/geospatial",
                layer = "MP14_SUBZONE_WEB_PL")
```

#### Importing LTA Cycling Path files:

```{r}
cyclingpath = st_read(dsn = "data/geospatial",
                      layer = "CyclingPathGazette")
```

#### Importing Preschools Location KML file files:

```{r}
preschool = st_read("data/geospatial/PreSchoolsLocation.kml")
```

# Checking the content of a simple feature data frame

#### Working with st_geometry()

This code displays the basic feature information.

```{r}
st_geometry(mpsz)
```

#### Working with glimpse()

This code reveals data type of each fields, and a glimpse of the data.

```{r}
glimpse(mpsz)
```

#### Working with head()

This code reveals complete info of a feature object.

```{r}
head(mpsz, n=5)
```

# Plotting the Geospatial Data

#### Simple visualisation

```{r}
plot(mpsz)
```

#### Plotting only the geometry

```{r}
plot(st_geometry(mpsz))
```

#### Plotting using specific attribute

```{r}
plot(mpsz["PLN_AREA_N"])
```

# Working with Projection

To perform geoprocessing using two geospatial data, we need to ensure that they are projected using similar coordinate system. In this section, I will be projecting a simple feature data frame from one coordinate system to another coordinate system.

```{r}
#| eval: false
st_crs(mpsz)
```

#### Assigning EPSG code to a simple feature data frame

```{r}
mpsz3414 <- st_set_crs(mpsz, 3414)
```

Checking that it is now 3414 (svy21):

```{r}
#| eval: false
st_crs(mpsz3414)
```

#### Transforming the projection of preschool from wgs84 to svy21

When we need to reproject one coordinate system to another coordinate system mathematically, we will use *`st_transform()`* instead of *`st_set_crs()`*.

Note: In practice, we need find out the appropriate project coordinate system to use before performing the projection transformation.

```{r}
preschool3414 <- st_transform(preschool, 
                              crs = 3414)
```

# Handling Aspatial Data

When the data comes in the form of two fields that capture the x and y coordinates of the data points, we call it **Aspatial Data.**

In this example, I will be using *listings.csv* data downloaded from AirBnb.

#### Importing the Aspatial Data

Importing the file

```{r}
listings <- read_csv("data/aspatial/listings.csv")
```

Examining the data file to ensure it has been imported correctly. The fields that I will be using is the latitude and longitude column, which corresponds to the x and y coordinate.

```{r}
list(listings)
```

#### Creating a simple feature data frame from an aspatial data frame

Now I will create a simple feature data frame from an aspatial data frame using *`st_as_sf()`* of sf packages.

```{r}
listings_sf <- st_as_sf(listings, 
                       coords = c("longitude", "latitude"),
                       crs=4326) %>%
  st_transform(crs = 3414)
```

Things to note:

-   **coords** argument requires you to provide the column name of the x-coordinates first then followed by the column name of the y-coordinates.

-   **crs** argument requires you to provide the coordinates system in epsg format. EPSG: 4326 is wgs84 Geographic Coordinate System and EPSG: 3414 is Singapore SVY21 Projected Coordinate System. You can search for other country's epsg code by referring to epsg.io.

-   **%\>%** is used to nest st_transform() to transform the newly created simple feature data frame into svy21 projected coordinates system.

Now if I use *`glimpse()`* on the newly created simple feature data frame, we can see that the longitude and latitude columns have been dropped, replaced by a new column called geometry.

```{r}
glimpse(listings_sf)
```

# Geoprocessing with sf package

In this section, I will be performing two commonly used geoprocessing functions, namely buffering and point in polygon count from the sf package.

#### Buffering

***Scenario:** The authority is planning to upgrade the exiting cycling path. To do so, they need to acquire 5 metres of reserved land on the both sides of the current cycling path. You are tasked to determine the extend of the land need to be acquired and their total area.*

**Solution:** First, I will use *`st_buffer()`* of **sf** package to compute the 5-meter buffers around the cycling paths.

```{r}
buffer_cycling <- st_buffer(cyclingpath, 
                               dist=5, nQuadSegs = 30)
```

Followed by calculating the area of the buffers using *`st_area()`*.

```{r}
buffer_cycling$AREA <- st_area(buffer_cycling)
```

Then we will derive the total land involved using *`sum()`*.

```{r}
sum(buffer_cycling$AREA)
```

#### Point-in-polygon count

***Scenario:** A pre-school service group want to find out the numbers of pre-schools in each Planning Subzone.*

**Solution:** I will be using two operations in one go, using *`st_intersects()`* to identify pre-schools located inside each Planning Subzone, then *`length()`* to calculate number of pre-schools identified in each planning subzone.

```{r}
mpsz3414$`PreSch Count`<- lengths(st_intersects(mpsz3414, preschool3414))
```

Summary statistics of the new PreSch Count field using *`summary()`*.

```{r}
summary(mpsz3414$`PreSch Count`)
```

Listing planning subzone with the most number of pre-school using *`top_n()`* of the **dplyr** package.

```{r}
top_n(mpsz3414, 1, `PreSch Count`)
```

Next, to calculate the density of pre-school by planning subzone, I will first use *`st_area()`* of **sf** package to derive the area of each planning subzone.

```{r}
mpsz3414$Area <- mpsz3414 %>%
  st_area()
```

I will then use *`mutate()`* of dplyr package to compute the density.

```{r}
mpsz3414 <- mpsz3414 %>%
  mutate(`PreSch Density` = `PreSch Count`/Area * 1000000)
```

# Exploratory Data Analysis (EDA)

In this section, I will be making use of appropriate **ggplot2** functions to create functional yet truthful statistical graphs for EDA purposes.

#### Histogram

The first graph will be a histogram to reveal the distribution of **PreSch Density.** I will first use *`hist()`* of R Graphics, which is limited in its quality and room for customisation.

```{r}
hist(mpsz3414$`PreSch Density`)
```

I will then make use of **ggplot2** functions to create a more comprehensive histogram.

```{r}
ggplot(data=mpsz3414, 
       aes(x= as.numeric(`PreSch Density`)))+
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") +
  labs(title = "Are pre-school even distributed in Singapore?",
       subtitle= "There are many planning sub-zones with a single pre-school, on the other hand, \nthere are two planning sub-zones with at least 20 pre-schools",
      x = "Pre-school density (per km sq)",
      y = "Frequency")
```

#### Scatterplot

Next, a scatterplot showing the relationship between **Pre-school Density** and **Pre-school Count.**

```{r}
ggplot(data=mpsz3414, 
       aes(y = `PreSch Count`, 
           x= as.numeric(`PreSch Density`)))+
  geom_point(color="black", 
             fill="light blue") +
  xlim(0, 40) +
  ylim(0, 40) +
  labs(title = "",
      x = "Pre-school density (per km sq)",
      y = "Pre-school count")
```
