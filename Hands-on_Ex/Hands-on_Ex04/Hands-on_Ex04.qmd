---
title: "Hands-on Exercise 4"
format: 
  html:
    code-fold: true
    code-summary: "Show code"
execute: 
  eval: true
  echo: true
  warning: false
date: "`r Sys.Date()`"
---

# Overview

In this hands-on exercise, we will learn how to compute spatial weights using R through the following:

-   import geospatial data using appropriate function(s) of sf package,
-   import csv file using appropriate function of readr package,
-   perform relational join using appropriate join function of dplyr package,
-   compute spatial weights using appropriate functions of spdep package, and
-   calculate spatially lagged variables using appropriate functions of spdep package.

# Getting Started

## Installing and loading R packages

The R packages that we will be using today are spdep, sf, tmap and tidyverse.

```{r}
pacman::p_load(sf, spdep, tmap, tidyverse, knitr)
```

## Importing Data

### Dataset

The two datasets that we are using today: - Hunan county boundary layer, a geospatial data set in ESRI shapefile format. - Hunan_2012.csv, a csv file containing selected Hunan's local development indicators in 2012.

### Import shapefile into r environment

We will use st_read() of sf package to import Hunan shapefile into R as a simple features Object of sf.

```{r}
hunan <- st_read(dsn = "data/geospatial", 
                 layer = "Hunan")
```

### Import csv file into r environment

Next, we will import Hunan_2012.csv into R by using read_csv() of readr package as a R dataframe class.

```{r}
hunan2012 <- read_csv("data/aspatial/Hunan_2012.csv")
```

### Performing relational join

Now, we will update the attribute table of hunan's SpatialPolygonsDataFrame with the attribute fields of hunan2012 dataframe by using left_join() of dplyr package.

```{r}
hunan <- left_join(hunan,hunan2012)%>%
  select(1:4, 7, 15)
```

# Visualising Regional Development Indicator

Now, we are going to prepare a basemap and a choropleth map showing the distribution of GDPPC 2012 by using qtm() of tmap package.

```{r}
basemap <- tm_shape(hunan) +
  tm_polygons() +
  tm_text("NAME_3", size=0.5)

gdppc <- qtm(hunan, "GDPPC")
tmap_arrange(basemap, gdppc, asp=1, ncol=2)
```

# Computing Contiguity Spatial Weights

In this section, we will use poly2nb() of spdep package to compute contiguity weight matrices for the study area. This function: - builds a neighbours list based on regions with contiguous boundaries. - has a "queen" argument that takes TRUE or FALSE as options, with default as TRUE.

Note: if "queen" argument = TRUE, more than a single shared boundary point is required to meet the contiguity condition.

## Computing (QUEEN) contiguity based neighbours

```{r}
wm_q <- poly2nb(hunan, queen=TRUE)
summary(wm_q)
```

Most connected region has 11 neighbors, 2 least connected region has 1 neighbor.

wm_q lists all neighboring polygon (in this case of polygon 1).

```{r}
wm_q[[1]]
```

Retrieving county name of Polygon 1 shows that it is "Anxiang".

```{r}
hunan$County[1]
```

County name of the 5 neighboring polygons.

```{r}
hunan$NAME_3[c(2,3,4,57,85)]
```

Retrieving GDPPC of these five countries.

```{r}
c1 <- wm_q[[1]]
c1 <- hunan$GDPPC[c1] # Filter GDPPC by the 5 polygons selected
c1
```

GDPPC of the five nearest neighbours based on Queen's method are 20981, 34592, 24473, 21311 and 22879 respectively.

Complete weight matrix:

```{r}
str(wm_q)
```

## Computing (ROOK) contiguity based neighbours

We will now compute Rook contiguity weight matrix

```{r}
wm_r <- poly2nb(hunan, queen=FALSE)
summary(wm_r)
```

Difference between Rook and Queen: The rook criterion defines neighbors by the existence of a common edge between two spatial units. The queen criterion is somewhat more encompassing and defines neighbors as spatial units sharing a common edge or a common vertex.

## Visualising contiguity weights

We will now be visualising contiguity weights using a connectivity graph, which takes a point and displays a line to each neighboring point. To do this we will need to get points from the polygons, and the most typical method will be polygon centroids. We will first calculate these in the sf package.

### Getting Latitude and Longitude of Polygon Centroids

TO get the points required to plot, we can't simply just use st_centroids as we need the coordinates in a seperate data frame. To do this we will use a mapping function that applies a given function to each element of a vector and returns a vector of the same length. In this case, we will use the geometry column as input, st_centroid as the function, and map_dbl variation of map from purrr package.

\[\[1\]\] retrieves only the longitude, whereas \[\[2\]\] retrieves the latitude.

```{r}
longitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])
```

```{r}
latitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])
```

Putting them into the same object.

```{r}
coords <- cbind(longitude, latitude)
```

Checking the first few observations.

```{r}
head(coords)
```

### Plotting Queen contiguity based neighbours map

```{r}
plot(hunan$geometry, border="lightgrey")
plot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= "red")
```

### Plotting Rook contiguity based neighbours map

```{r}
plot(hunan$geometry, border="lightgrey")
plot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = "red")
```

### Plotting both Queen and Rook contiguity based neighbours maps

For easier comparison

```{r}
par(mfrow=c(1,2))
plot(hunan$geometry, border="lightgrey", main="Queen Contiguity")
plot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= "red")
plot(hunan$geometry, border="lightgrey", main="Rook Contiguity")
plot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = "red")
```

# Computing distance based neighbours

In this section, we will be deriving distance-based weight matrices by using dnearneigh() of spdep package.

The function identifies neighbours of region points by Euclidean distance with a distance band with lower d1= and upper d2= bounds controlled by the bounds= argument. If unprojected coordinates are used and either specified in the coordinates object x or with x as a two column matrix and longlat=TRUE, great circle distances in km will be calculated assuming the WGS84 reference ellipsoid. (Need further clarifications)

## Determine the cut-off distance

The first step is to determine the upper limit for distance band, which can be done by the following steps: - Return a matrix with the indices of points belonging to the set of the k nearest neighbours of each other by using knearneigh() of spdep. - Convert the knn object returned by knearneigh() into a neighbours list of class nb with a list of integer vectors containing neighbour region number ids by using knn2nb(). - Return the length of neighbour relationship edges by using nbdists() of spdep. The function returns in the units of the coordinates if the coordinates are projected, in km otherwise. - Remove the list structure of the returned object by using unlist().

```{r}
#coords <- coordinates(hunan)
k1 <- knn2nb(knearneigh(coords))
k1dists <- unlist(nbdists(k1, coords, longlat = TRUE))
summary(k1dists)
```

Summary statistics shows that the largest first nearest neighbour distance is 61.79 km, which we will be using as upper limit.

## Computing fixed distance weight matrix

```{r}
wm_d62 <- dnearneigh(coords, 0, 62, longlat = TRUE) # 62 is upper limit
wm_d62
```

Displaying the content of wm_d62 weight matrix:

```{r}
#| eval: false
str(wm_d62)
```

Another way to display:

```{r}
table(hunan$County, card(wm_d62))
```

### Plotting fixed distance weight matrix

```{r}
plot(hunan$geometry, border="lightgrey")
plot(wm_d62, coords, add=TRUE)
plot(k1, coords, add=TRUE, col="red", length=0.08)
```

Red line = 1st nearest neighbours Black lines = links of neighbours within the cut-off distance of 62km.

## Computing adaptive distance weight matrix

When computing fixed distance weight matrix, more densely settled areas tend to have more neighbours than less densely settled areas (urban vs rural). Having many neighbours smoothes the neighbour relationship across more neighbours.

It is possible to control the numbers of neighbours directly using k-nearest neighbours, either by accepting asymmetric neighbours or imposing symmetry as shown in the code chunk below.

```{r}
knn6 <- knn2nb(knearneigh(coords, k=6))
knn6
```

Displaying content of the matrix

```{r}
#| eval: false
str(knn6)
```

In this matrix, each country has exactly 6 neighbors.

### Plotting distance based neighbours

```{r}
plot(hunan$geometry, border="lightgrey")
plot(knn6, coords, pch = 19, cex = 0.6, add = TRUE, col = "red")
```

# Weights based on IDW

In this section, we will learn how to derive a spatial weight matrix based on Inversed Distance method.

First, we will compute the distances between areas by using nbdists() of spdep package.

```{r}
# Recap: wm_q is list of all neighboring polygon, coords is list of coordinates
dist <- nbdists(wm_q, coords, longlat = TRUE)
ids <- lapply(dist, function(x) 1/(x))
ids
```

## Row-standardised weights matrix

Next, we need to assign weights to each neighboring polygon.In our case, each neighboring polygon will be assigned equal weight (style="W"). This is accomplished by assigning the fraction 1/(#ofneighbors) to each neighboring county then summing the weighted income values. While this is the most intuitive way to summaries the neighbors' values it has one drawback in that polygons along the edges of the study area will base their lagged values on fewer polygons thus potentially over- or under-estimating the true nature of the spatial autocorrelation in the data. For this example, we'll stick with the style="W" option for simplicity's sake but note that other more robust options are available, notably style="B".

```{r}
rswm_q <- nb2listw(wm_q, style="W", zero.policy = TRUE)
rswm_q
```

The zero.policy=TRUE option allows for lists of non-neighbors. This should be used with caution since the user may not be aware of missing neighbors in their dataset however, a zero.policy of FALSE would return an error.

Weight of the first polygon's eight neighbors type:

```{r}
rswm_q$weights[10]
```

Each neighbor has an equal weight of 0.125. This means that when R computes the average neighboring income values, each neighbor's income will be multiplied by 0.125 before being tallied.

Row standardised distance weight matrix

```{r}
rswm_ids <- nb2listw(wm_q, glist=ids, style="B", zero.policy=TRUE)
rswm_ids
```

```{r}
rswm_ids$weights[1]
```

```{r}
summary(unlist(rswm_ids$weights))
```

(To do further research on what this does)

# Application of Spatial Weight Matrix

In this section, we will learn how to create four different spatial lagged variables: - spatial lag with row-standardized weights, - spatial lag as a sum of neighbouring values, - spatial window average, and - spatial window sum. + what they do

## Spatial lag with row-standardized weights

spatially lagged values - average neighbor GDPPC value for each polygon

```{r}
GDPPC.lag <- lag.listw(rswm_q, hunan$GDPPC)
GDPPC.lag
```

GDPPC of the five countries retrieved in previous section

```{r}
nb1 <- wm_q[[1]]
nb1 <- hunan$GDPPC[nb1]
nb1

# mean of these adds up to first value of GDPPC.lag, as it should 
```

Appending the spatially lag GDPPC values onto hunan sf data frame

```{r}
lag.list <- list(hunan$NAME_3, lag.listw(rswm_q, hunan$GDPPC))
lag.res <- as.data.frame(lag.list)
colnames(lag.res) <- c("NAME_3", "lag GDPPC")
hunan <- left_join(hunan,lag.res)
```

Table showing the average neighboring GDPPC values (stored in the lag GDPPC object) for each county.

```{r}
head(hunan)
```

Next, we will plot both the GDPPC and spatial lag GDPPC for comparison using the code chunk below.

```{r}
gdppc <- qtm(hunan, "GDPPC")
lag_gdppc <- qtm(hunan, "lag GDPPC")
tmap_arrange(gdppc, lag_gdppc, asp=1, ncol=2)
```

## Spatial lag as a sum of neighboring values

We can calculate spatial lag as a sum of neighboring values by assigning binary weights. This requires us to go back to our neighbors list, then apply a function that will assign binary weights, then we use glist = in the nb2listw function to explicitly assign these weights.

We start by applying a function that will assign a value of 1 per each neighbor. This is done with lapply, which we have been using to manipulate the neighbors structure throughout the past notebooks. Basically it applies a function across each value in the neighbors structure.

```{r}
b_weights <- lapply(wm_q, function(x) 0*x + 1)
b_weights2 <- nb2listw(wm_q, 
                       glist = b_weights, 
                       style = "B")
b_weights2
```

With the proper weights assigned, we can use lag.listw to compute a lag variable from our weight and GDPPC.

```{r}
lag_sum <- list(hunan$NAME_3, lag.listw(b_weights2, hunan$GDPPC))
lag.res <- as.data.frame(lag_sum)
colnames(lag.res) <- c("NAME_3", "lag_sum GDPPC")
```

Examining the results

```{r}
lag_sum
```

Next, we will append the lag_sum GDPPC field into hunan sf data frame.

```{r}
hunan <- left_join(hunan, lag.res)
```

Plotting both the GDPPC and Spatial Lag Sum GDPPC for comparison.

```{r}
gdppc <- qtm(hunan, "GDPPC")
lag_sum_gdppc <- qtm(hunan, "lag_sum GDPPC")
tmap_arrange(gdppc, lag_sum_gdppc, asp=1, ncol=2)
```

## Spatial window average

The spatial window average uses row-standardized weights and includes the **diagonal element**. To do this in R, we need to go back to the neighbors structure and add the diagonal element before assigning weights.

To add the diagonal element to the neighbour list, we just need to use include.self() from spdep.

```{r}
wm_qs <- include.self(wm_q)
```

```{r}
wm_qs[[1]]
```

Polygon \[1\] now has 6 neighbors (including self) instead of 5.

Now we obtain weights with nb2listw()

```{r}
wm_qs <- nb2listw(wm_qs)
wm_qs
```

Creating the lag variable from our weight structure and GDPPC variable.

```{r}
lag_w_avg_gpdpc <- lag.listw(wm_qs, 
                             hunan$GDPPC)
lag_w_avg_gpdpc
```

Converting the lag variable listw object into a data.frame by using as.data.frame().

```{r}
lag.list.wm_qs <- list(hunan$NAME_3, lag.listw(wm_qs, hunan$GDPPC))
lag_wm_qs.res <- as.data.frame(lag.list.wm_qs)
colnames(lag_wm_qs.res) <- c("NAME_3", "lag_window_avg GDPPC")
```

Appending lag_window_avg GDPPC values onto hunan sf data.frame by using left_join() of dplyr package.

```{r}
hunan <- left_join(hunan, lag_wm_qs.res)
```

To compare the values of lag GDPPC and Spatial window average, kable() of Knitr package is used to prepare a table.

```{r}
hunan %>%
  select("County", 
         "lag GDPPC", 
         "lag_window_avg GDPPC") %>%
  kable()
```

Using qtm() of tmap package to plot the lag_gdppc and w_ave_gdppc maps next to each other for quick comparison.

```{r}
w_avg_gdppc <- qtm(hunan, "lag_window_avg GDPPC")
tmap_arrange(lag_gdppc, w_avg_gdppc, asp=1, ncol=2)
```

## Spatial window sum

The spatial window sum is the counter part of the window average, but without using row-standardized weights.

Adding the diagonal element to the neighbour list again

```{r}
wm_qs <- include.self(wm_q)
wm_qs
```

Assigning binary weights to the neighbour structure that includes the diagonal element.

```{r}
b_weights <- lapply(wm_qs, function(x) 0*x + 1)
b_weights[1]
```

Again, we use nb2listw() and glist() to explicitly assign weight values.

```{r}
b_weights2 <- nb2listw(wm_qs, 
                       glist = b_weights, 
                       style = "B")
b_weights2
```

Computing the lag variable with lag.listw().

```{r}
w_sum_gdppc <- list(hunan$NAME_3, lag.listw(b_weights2, hunan$GDPPC))
w_sum_gdppc
```

Converting the lag variable listw object into a data.frame by using as.data.frame().

```{r}
w_sum_gdppc.res <- as.data.frame(w_sum_gdppc)
colnames(w_sum_gdppc.res) <- c("NAME_3", "w_sum GDPPC")
```

Appending w_sum GDPPC values onto hunan sf data.frame by using left_join() of dplyr package.

```{r}
hunan <- left_join(hunan, w_sum_gdppc.res)
```

Comparing the values of lag GDPPC and Spatial window average using kable() of Knitr package.

```{r}
hunan %>%
  select("County", "lag_sum GDPPC", "w_sum GDPPC") %>%
  kable()
```

Using qtm() of tmap package to plot the lag_sum GDPPC and w_sum_gdppc maps next to each other for quick comparison.

```{r}
w_sum_gdppc <- qtm(hunan, "w_sum GDPPC")
tmap_arrange(lag_sum_gdppc, w_sum_gdppc, asp=1, ncol=2)
```
