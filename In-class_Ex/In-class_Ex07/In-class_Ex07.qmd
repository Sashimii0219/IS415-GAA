---
title: "In-class Exercise 7"
format: 
  html:
    code-fold: true
    code-summary: "Show code"
execute: 
  eval: true
  echo: true
  freeze: auto
  warning: false
date: "`r Sys.Date()`"
---

# 1. Learning Objective

In this hands-on exercise, we will learn how to delineate homogeneous region by using geographically referenced multivariate data. There are two major analysis, namely:

-   hierarchical cluster analysis; and

-   spatially constrained cluster analysis.

# 2. Getting Started

## 2.1 Context

In geobusiness and spatial policy, it is a common practice to delineate the market or planning area into homogeneous regions by using multivariate data. In this hands-on exercise, we are interested to delineate [Shan State](https://en.wikipedia.org/wiki/Shan_State), [Myanmar](https://en.wikipedia.org/wiki/Myanmar) into homogeneous regions by using multiple Information and Communication technology (ICT) measures, namely: Radio, Television, Land line phone, Mobile phone, Computer, and Internet at home.

## **2.2 Loading R Packages**

The R packages that we will be using are:

-   Spatial data handling

    -   **sf**, **rgdal** and **spdep**

-   Attribute data handling

    -   **tidyverse**, especially **readr**, **ggplot2** and **dplyr**

-   Choropleth mapping

    -   **tmap**

-   Multivariate data visualisation and analysis

    -   **coorplot**, **ggpubr**, and **heatmaply**

-   Cluster analysis

    -   **cluster**

    -   **ClustGeo**

```{r}
pacman::p_load(sp, spdep, tmap, sf, ClustGeo, 
               ggpubr, cluster, factoextra, NbClust,
               heatmaply, corrplot, psych, tidyverse, GGally)
```

## 2.3 Data Importing and Preparation

### 2.3.1 Dataset

We will be using the following dataset in this hands-on exercise:

-   Myanmar Township Boundary Data (i.e.Â *myanmar_township_boundaries*) - A GIS data in ESRI shapefile format. It consists of township boundary information of Myanmar. The spatial data are captured in polygon features.

-   *Shan-ICT.csv* - An extract of [**The 2014 Myanmar Population and Housing Census Myanmar**](https://myanmar.unfpa.org/en/publications/2014-population-and-housing-census-myanmar-data-sheet) at the township level.

### 2.3.2 Importing Data

We will be importing the Myanmar Township Boundary GIS data in ESRI shapefile format using the *`st_read()`* function of **sf**.

```{r}
shan_sf <- st_read(dsn = "data/geospatial", 
                   layer = "myanmar_township_boundaries") %>%
  filter(ST %in% c("Shan (East)", "Shan (North)", "Shan (South)")) %>%
  select(c(2:7))
```

We will then import InfoComm variables extracted from **The 2014 Myanmar Population and Housing Census Myanmar**.

```{r}
ict <- read_csv ("data/aspatial/Shan-ICT.csv")
```

### 2.3.3 Deriving new variables

The unit of measurement in this exercise is the number of households. Using these values directly will be bias by the underlying total number of households. In general, the townships with relatively higher total number of households will also have higher number of households owning radio, TV, etc.

In order to overcome this problem, we will derive the penetration rate of each ICT variable by finding proportion of number of households instead.

```{r}
ict_derived <- ict %>%
  mutate(`RADIO_PR` = `Radio`/`Total households`*1000) %>%
  mutate(`TV_PR` = `Television`/`Total households`*1000) %>%
  mutate(`LLPHONE_PR` = `Land line phone`/`Total households`*1000) %>%
  mutate(`MPHONE_PR` = `Mobile phone`/`Total households`*1000) %>%
  mutate(`COMPUTER_PR` = `Computer`/`Total households`*1000) %>%
  mutate(`INTERNET_PR` = `Internet at home`/`Total households`*1000) %>%
  rename(`DT_PCODE` =`District Pcode`,`DT`=`District Name`,
         `TS_PCODE`=`Township Pcode`, `TS`=`Township Name`,
         `TT_HOUSEHOLDS`=`Total households`,
         `RADIO`=`Radio`, `TV`=`Television`, 
         `LLPHONE`=`Land line phone`, `MPHONE`=`Mobile phone`,
         `COMPUTER`=`Computer`, `INTERNET`=`Internet at home`) 
```

```{r}
summary(ict_derived)
```

# 3. **Exploratory Data Analysis (EDA)**

## 3.1 Statistical Graphs

Let's plot the distribution of the variables.

#### Histogram

```{r}
ggplot(data=ict_derived, 
       aes(x=`RADIO`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")
```

#### Boxplot

```{r}
ggplot(data=ict_derived, 
       aes(x=`RADIO`)) +
  geom_boxplot(color="black", 
               fill="light blue")
```

#### Histogram for penetration rate

```{r}
ggplot(data=ict_derived, 
       aes(x=`RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")
```

#### Multiple Histograms

We will first create each individual histogram

```{r}
radio <- ggplot(data=ict_derived, 
             aes(x= `RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

tv <- ggplot(data=ict_derived, 
             aes(x= `TV_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

llphone <- ggplot(data=ict_derived, 
             aes(x= `LLPHONE_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

mphone <- ggplot(data=ict_derived, 
             aes(x= `MPHONE_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

computer <- ggplot(data=ict_derived, 
             aes(x= `COMPUTER_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")

internet <- ggplot(data=ict_derived, 
             aes(x= `INTERNET_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue")
```

We will then use the *`ggarrange()`* function of **ggpubr** package to group these histograms together.

```{r}
ggarrange(radio, tv, llphone, mphone, computer, internet, 
          ncol = 3, 
          nrow = 2)
```

## **3.2 Choropleth maps**

Before we can prepare the choropleth map, we need to combine both the geospatial data object aspatial data.frame object into one, with *shan_sf* simple feature data.frame as the base data object and the *ict_derived* data.frame as the join table.

```{r}
#| eval: false
shan_sf <- left_join(shan_sf, 
                     ict_derived, by=c("TS_PCODE"="TS_PCODE"))
  
write_rds(shan_sf, "data/rds/shan_sf.rds")
```

```{r}
shan_sf <- read_rds("data/rds/shan_sf.rds")
```

### 3.2.1 Preparing a choropleth map

We will now have a quick look at the distribution of Radio penetration rate of Shan State at township level using a choropleth map.

```{r}
qtm(shan_sf, "RADIO_PR")
```

To visualise the bias to the underlying total number of households at the townships, we will create two choropleth maps, one for the total number of households and one for the total number of household with Radio.

```{r}
TT_HOUSEHOLDS.map <- tm_shape(shan_sf) + 
  tm_fill(col = "TT_HOUSEHOLDS",
          n = 5,
          style = "jenks", 
          title = "Total households") + 
  tm_borders(alpha = 0.5) 

RADIO.map <- tm_shape(shan_sf) + 
  tm_fill(col = "RADIO",
          n = 5,
          style = "jenks",
          title = "Number Radio ") + 
  tm_borders(alpha = 0.5) 

tmap_arrange(TT_HOUSEHOLDS.map, RADIO.map,
             asp=NA, ncol=2)
```

Notice that the choropleth maps above clearly shows that townships with relatively larger number of households are also showing relatively higher number of radio ownership.

Now let us plot the choropleth maps showing the dsitribution of total number of households and Radio penetration rate.

```{r}
tm_shape(shan_sf) +
    tm_polygons(c("TT_HOUSEHOLDS", "RADIO_PR"),
                style="jenks") +
    tm_facets(sync = TRUE, ncol = 2) +
  tm_legend(legend.position = c("right", "bottom"))+
  tm_layout(outer.margins=0, asp=0)
```

The area with high radio penetration rate is different from towns with higher number of households.

# **4. Correlation Analysis**

Before we perform cluster analysis, it is important for us to ensure that the cluster variables are not highly correlated. To do that, we will use *`corrplot.mixed()`* function of **corrplot** package to visualise and analyse the correlation of the input variables.

```{r}
cluster_vars.cor = cor(ict_derived[,12:17])
corrplot.mixed(cluster_vars.cor,
         lower = "ellipse", 
               upper = "number",
               tl.pos = "lt",
               diag = "l",
               tl.col = "black")
```

The correlation plot above shows that COMPUTER_PR and INTERNET_PR are highly correlated. This suggest that only one of them should be used in the cluster analysis instead of both.

# **5. Hierarchical Cluster Analysis**

We will now perform hierarchical cluster analysis, which consists of four steps:

## 5.1 **Extracting clustering variables**

```{r}
cluster_vars <- shan_sf %>%
  st_set_geometry(NULL) %>%
  select("TS.x", "RADIO_PR", "TV_PR", "LLPHONE_PR", "MPHONE_PR", "COMPUTER_PR")
head(cluster_vars,10)
```

We excluded the variable INTERNET_PR from the final clustering variables list because it is highly correlated with variable COMPUTER_PR.

Next, we need to change the rows by township name instead of row number, then delete the TS.x field.

```{r}
row.names(cluster_vars) <- cluster_vars$"TS.x"

shan_ict <- select(cluster_vars, c(2:6))
head(shan_ict, 10)
```

## 5.2 **Data Standardisation**

In general, multiple variables will be used in cluster analysis. In order to avoid the cluster analysis result being biased to clustering variables with larger values, it is useful to standardise the input variables before performing cluster analysis.

### 5.2.1 **Min-Max standardisation**

*We will* standardise the clustering variables by using Min-Max method under *`normalize()`* of [*heatmaply*](https://cran.r-project.org/web/packages/heatmaply/) package.

```{r}
shan_ict.std <- normalize(shan_ict)
summary(shan_ict.std)
```

Notice that the values range of the Min-max standardised clustering variables are 0-1 now.

### 5.2.2 **Z-score standardisation**

We will perform Z-score standardisation using *`scale()`* of Base R.

```{r}
shan_ict.z <- scale(shan_ict)
describe(shan_ict.z)
```

Notice the mean and standard deviation of the Z-score standardised clustering variables are 0 and 1 respectively.

***Warning: Z-score standardisation method should only be used if we would assume all variables come from some normal distribution.***

## 5.3 **Visualising the standardised clustering variables**

Beside reviewing the summary statistics of the standardised clustering variables, it is also a good practice to visualise their distribution graphical.

```{r}
r <- ggplot(data=ict_derived, 
             aes(x= `RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") +
  ggtitle("Raw values without standardisation")

shan_ict_s_df <- as.data.frame(shan_ict.std)
s <- ggplot(data=shan_ict_s_df, 
       aes(x=`RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") +
  ggtitle("Min-Max Standardisation")

shan_ict_z_df <- as.data.frame(shan_ict.z)
z <- ggplot(data=shan_ict_z_df, 
       aes(x=`RADIO_PR`)) +
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") +
  ggtitle("Z-score Standardisation")

ggarrange(r, s, z,
          ncol = 3,
          nrow = 1)
```

```{r}
r <- ggplot(data=ict_derived, 
             aes(x= `RADIO_PR`)) +
  geom_density(color="black",
               fill="light blue") +
  ggtitle("Raw values without standardisation")

shan_ict_s_df <- as.data.frame(shan_ict.std)
s <- ggplot(data=shan_ict_s_df, 
       aes(x=`RADIO_PR`)) +
  geom_density(color="black",
               fill="light blue") +
  ggtitle("Min-Max Standardisation")

shan_ict_z_df <- as.data.frame(shan_ict.z)
z <- ggplot(data=shan_ict_z_df, 
       aes(x=`RADIO_PR`)) +
  geom_density(color="black",
               fill="light blue") +
  ggtitle("Z-score Standardisation")

ggarrange(r, s, z,
          ncol = 3,
          nrow = 1)
```

## 5.4 **Computing proximity matrix**

We will compute the proximity matrix by using [*dist()*](https://stat.ethz.ch/R-manual/R-devel/library/stats/html/dist.html) of R, utilising the *euclidean* method.

```{r}
proxmat <- dist(shan_ict, method = 'euclidean')
```

Listing the content of *proxmat* for visual inspection.

```{r}
proxmat
```

## 5.5 **Computing hierarchical clustering**

Now, we will make use of *hclust()* which employ agglomeration method to compute the cluster using ward.D method. The hierarchical clustering output is stored in an object of class **hclust** which describes the tree produced by the clustering process.

```{r}
hclust_ward <- hclust(proxmat, method = 'ward.D')
```

```{r}
plot(hclust_ward, cex = 0.6)
```

## 5.6 **Selecting the optimal clustering algorithm**

One of the challenge in performing hierarchical clustering is to identify stronger clustering structures. The issue can be solved by using use *`agnes()`* function of **cluster** package. It functions like *`hclus()`*, however, with the *`agnes()`* function you can also get the agglomerative coefficient, which measures the amount of clustering structure found (values closer to 1 suggest strong clustering structure).

```{r}
m <- c( "average", "single", "complete", "ward")
names(m) <- c( "average", "single", "complete", "ward")

ac <- function(x) {
  agnes(shan_ict, method = x)$ac
}

map_dbl(m, ac)
```

With reference to the output above, we can see that Ward's method provides the strongest clustering structure among the four methods assessed. Hence, in the subsequent analysis, only Ward's method will be used.

## **5.7 Determining Optimal Clusters**

There are three commonly used methods to determine the optimal clusters, they are:

-   Elbow Method

-   Average Silhouette Method

-   Gap Statistic Method

### 5.7.1 Gap Statistic Method

The **gap statistic** compares the total within intra-cluster variation for different values of k with their expected values under null reference distribution of the data. The estimate of the optimal clusters will be value that maximize the gap statistic. This means that the clustering structure is far away from the random uniform distribution of points.

We will use *clusGap()* of **cluster** package to compute the gap statistic.

```{r}
set.seed(12345)
gap_stat <- clusGap(shan_ict, 
                    FUN = hcut, 
                    nstart = 25, 
                    K.max = 10, 
                    B = 50)
# Print the result
print(gap_stat, method = "firstmax")
```

Next, we will visualise them using *`fviz_gap_stat()`* of **factoextra** package.

```{r}
fviz_gap_stat(gap_stat)
```

With reference to the gap statistic graph above, the recommended number of cluster to retain is 1. However, it is not logical to retain only one cluster. By examine the gap statistic graph, the 6-cluster gives the largest gap statistic and should be the next best cluster to pick.

## **5.8 Interpreting the dendrograms**

In the dendrogram displayed above, each leaf corresponds to one observation. As we move up the tree, observations that are similar to each other are combined into branches, which are themselves fused at a higher height.

The height of the fusion, provided on the vertical axis, indicates the (dis)similarity between two observations. The higher the height of the fusion, the less similar the observations are. Note that, conclusions about the proximity of two observations can be drawn only based on the height where branches containing those two observations first are fused. We cannot use the proximity of two observations along the horizontal axis as a criteria of their similarity.

It's also possible to draw the dendrogram with a border around the selected clusters by using *`rect.hclust()`* of R stats. The argument *border* is used to specify the border colors for the rectangles.

```{r}
plot(hclust_ward, cex = 0.6)
rect.hclust(hclust_ward, 
            k = 6, 
            border = 2:5)
```

## 5.9 **Visually-driven hierarchical clustering analysis**

With **heatmaply**, we are able to build both highly interactive cluster heatmap or static cluster heatmap. We first need to transform *shan_ict* data frame into a data matrix.

```{r}
shan_ict_mat <- data.matrix(shan_ict)
```

Then, we will use the *`heatmaply()`* of heatmaply package to build an interactive cluster heatmap.

```{r}
heatmaply(normalize(shan_ict_mat),
          Colv=NA,
          dist_method = "euclidean",
          hclust_method = "ward.D",
          seriate = "OLO",
          colors = Blues,
          k_row = 6,
          margins = c(NA,200,60,NA),
          fontsize_row = 4,
          fontsize_col = 5,
          main="Geographic Segmentation of Shan State by ICT indicators",
          xlab = "ICT Indicators",
          ylab = "Townships of Shan State"
          )
```

## **5.10 Mapping the clusters formed**

*`cutree()`* of R Base will be used in the code chunk below to derive a 6-cluster model.

```{r}
groups <- as.factor(cutree(hclust_ward, k=6))
```

In order to visualise the clusters, the *groups* object need to be appended onto *shan_sf* simple feature object.

```{r}
shan_sf_cluster <- cbind(shan_sf, as.matrix(groups)) %>%
  rename(`CLUSTER`=`as.matrix.groups.`)
```

Next, *qtm()* of **tmap** package is used to plot the choropleth map showing the cluster formed.

```{r}
qtm(shan_sf_cluster, "CLUSTER")
```

The choropleth map above reveals the clusters are very fragmented. The is one of the major limitation when non-spatial clustering algorithm such as hierarchical cluster analysis method is used.

# **6. Spatially Constrained Clustering: SKATER approach**

In this section, we will derive spatially constrained cluster by using *`skater()`* method of **spdep** package.

## 6.1 **Converting into SpatialPolygonsDataFrame**

NO NEED ANYMORE

We will use *as_Spatial()* of **sf** package to convert *shan_sf* into a SpatialPolygonDataFrame.

```{r}
shan_sp <- as_Spatial(shan_sf)
```

## **6.1 Computing Neighbour List**

```{r}
shan.nb <- poly2nb(shan_sf)
summary(shan.nb)
```

```{r}
plot(shan_sp, 
     border=grey(.5))
plot(shan.nb, 
     coordinates(shan_sp), 
     col="blue", 
     add=TRUE)
```

Note that if you plot the network first and then the boundaries, some of the areas will be clipped. This is because the plotting area is determined by the characteristics of the first plot. In this example, because the boundary map extends further than the graph, we plot it first.

## **6.2 Computing minimum spanning tree**

### 6.2.1 Calculating edge costs

Now we will calculate the cost of each edge, which is the distance between each nodes. This function compute this distance using a data.frame with observations vector in each node.

```{r}
lcosts <- nbcosts(shan.nb, shan_ict)
```

For each observation, this gives the pairwise dissimilarity between its values on the five variables and the values for the neighbouring observation (from the neighbour list). Basically, this is the notion of a generalised weight for a spatial weights matrix.

Next, We will incorporate these costs into a weights object in the same way as we did in the calculation of inverse of distance weights. In other words, we convert the neighbour list to a list weights object by specifying the just computed ***lcosts*** as the weights.

In order to achieve this, we will be using *`nb2listw()`* of **spdep** package.

Note that we specify the *style* as **B** to make sure the cost values are not row-standardised.

```{r}
shan.w <- nb2listw(shan.nb, 
                   lcosts, 
                   style="B")
summary(shan.w)
```

## **6.3 Computing minimum spanning tree**

The minimum spanning tree is computed by mean of the *`mstree()`* of **spdep** package as shown in the code chunk below.

```{r}
shan.mst <- mstree(shan.w)
```

After computing the MST, we will check its class and dimension.

```{r}
class(shan.mst)

dim(shan.mst)
```

Note that the dimension is 54 and not 55. This is because the minimum spanning tree consists on n-1 edges (links) in order to traverse all the nodes.

We can display the content of *shan.mst* by using *head()* as shown in the code chunk below.

```{r}
head(shan.mst)
```

The plot method for the MST include a way to show the observation numbers of the nodes in addition to the edge. As before, we plot this together with the township boundaries. We can see how the initial neighbour list is simplified to just one edge connecting each of the nodes, while passing through all the nodes.

```{r}
plot(shan_sp, border=gray(.5))
plot.mst(shan.mst, 
         coordinates(shan_sp), 
         col="blue", 
         cex.lab=0.7, 
         cex.circles=0.005, 
         add=TRUE)
```

## **6.4 Computing spatially constrained clusters using SKATER method**

Next up we will compute the spatially constrained cluster using *`skater()`* of **spdep** package.

```{r}
clust6 <- spdep::skater(edges = shan.mst[,1:2], 
                 data = shan_ict, 
                 method = "euclidean", 
                 ncuts = 5)
```

Results.

```{r}
str(clust6)

```

he most interesting component of this list structure is the groups vector containing the labels of the cluster to which each observation belongs (as before, the label itself is arbitary). This is followed by a detailed summary for each of the clusters in the edges.groups list. Sum of squares measures are given as ssto for the total and ssw to show the effect of each of the cuts on the overall criterion.

We will now check the cluster assignment .

```{r}
ccs6 <- clust6$groups
ccs6
```

We can find out how many observations are in each cluster by means of the table command. Parenthetially, we can also find this as the dimension of each vector in the lists contained in edges.groups. For example, the first list has node with dimension 12, which is also the number of observations in the first cluster.

```{r}
table(ccs6)
```

Plotting pruned trees of the five clusters above.

```{r}
plot(shan_sp, border=gray(.5))
plot(clust6, 
     coordinates(shan_sp), 
     cex.lab=.7,
     groups.colors=c("red","green","blue", "brown", "pink"),
     cex.circles=0.005, 
     add=TRUE)
```

### **12.8.6 Visualising the clusters in choropleth map**

## **6.5 Visualising the clusters in choropleth map**

```{r}
groups_mat <- as.matrix(clust6$groups)
shan_sf_spatialcluster <- cbind(shan_sf_cluster, as.factor(groups_mat)) %>%
  rename(`SP_CLUSTER`=`as.factor.groups_mat.`)
qtm(shan_sf_spatialcluster, "SP_CLUSTER")
```

For easier comparison, ler's plot both the hierarchical clustering and spatially constrained hierarchical clustering maps next to each other.

```{r}
hclust.map <- qtm(shan_sf_cluster,
                  "CLUSTER") + 
  tm_borders(alpha = 0.5) 

shclust.map <- qtm(shan_sf_spatialcluster,
                   "SP_CLUSTER") + 
  tm_borders(alpha = 0.5) 

tmap_arrange(hclust.map, shclust.map,
             asp=NA, ncol=2)
```

# **7. Spatially Constrained Clustering: ClustGeo Method**

In this section, we will use **ClustGeo** package, an R package specially designed to support the need of performing spatially constrained cluster analysis. More specifically, it provides a Ward-like hierarchical clustering algorithm called `hclustgeo()` including spatial/geographical constraints. We will use it to perform non-spatially constrained hierarchical cluster analysis and spatially constrained cluster analysis.

In the nutshell, the algorithm uses two dissimilarity matrices D0 and D1 along with a mixing parameter alpha, whereby the value of alpha must be a real number between \[0, 1\]. D0 can be non-Euclidean and the weights of the observations can be non-uniform. It gives the dissimilarities in the **attribute/clustering variable space**. D1, on the other hand, gives the dissimilarities in the **constraint space**. The criterion minimised at each stage is a convex combination of the homogeneity criterion calculated with D0 and the homogeneity criterion calculated with D1.

The idea is then to determine a value of alpha which increases the spatial contiguity without deteriorating too much the quality of the solution based on the variables of interest. This need is supported by a function called `choicealpha()`.

## **7.1 Ward-like hierarchical clustering: ClustGeo**

To perform non-spatially constrained hierarchical clustering, we only need to provide the function a dissimilarity matrix.

```{r}
nongeo_cluster <- hclustgeo(proxmat)
plot(nongeo_cluster, cex = 0.5)
rect.hclust(nongeo_cluster, 
            k = 6, 
            border = 2:5)
```

### 7.1.1 Mapping the clusters formed

Similarly, we can plot the clusters on a categorical area shaded map by using the steps we learned in previous steps.

```{r}
groups <- as.factor(cutree(nongeo_cluster, k=6))
```

```{r}
shan_sf_ngeo_cluster <- cbind(shan_sf, as.matrix(groups)) %>%
  rename(`CLUSTER` = `as.matrix.groups.`)
```

```{r}
qtm(shan_sf_ngeo_cluster, "CLUSTER")
```

### **7.2 Spatially Constrained Hierarchical Clustering**

Before we can performed spatially constrained hierarchical clustering, a spatial distance matrix will be derived by using *`st_distance()`* of sf package.

```{r}
dist <- st_distance(shan_sf, shan_sf)
distmat <- as.dist(dist)
```

Next, we will use *`choicealpha()`* to determine a suitable value for the mixing parameter alpha.

```{r}
cr <- choicealpha(proxmat, distmat, range.alpha = seq(0, 1, 0.1), K=6, graph = TRUE)
```

With reference to the graphs above, we will be using alpha = 0.3.

```{r}
clustG <- hclustgeo(proxmat, distmat, alpha = 0.3)
```

Next, *`cutree()`* is used to derive the cluster objecct.

```{r}
groups <- as.factor(cutree(clustG, k=6))
```

We will then join back the group list with *shan_sf* polygon feature data frame.

```{r}
shan_sf_Gcluster <- cbind(shan_sf, as.matrix(groups)) %>%
  rename(`CLUSTER` = `as.matrix.groups.`)
```

Now let's plot the map of the newly delineated spatially constrained clusters.

```{r}
qtm(shan_sf_Gcluster, "CLUSTER")

```

# **8. Visual Interpretation of Clusters**

### **8.1 Visualising individual clustering variable**

Code chunk below is used to reveal the distribution of a clustering variable (i.e RADIO_PR) by cluster.

```{r}
ggplot(data = shan_sf_ngeo_cluster,
       aes(x = CLUSTER, y = RADIO_PR)) +
  geom_boxplot()
```

## **8.2 Multivariate Visualisation**

Past studies shown that parallel coordinate plot can be used to reveal clustering variables by cluster very effectively. In the code chunk below, *`ggparcoord()`* of **GGally** package

```{r}
ggparcoord(data = shan_sf_ngeo_cluster, 
           columns = c(17:21), 
           scale = "globalminmax",
           alphaLines = 0.2,
           boxplot = TRUE, 
           title = "Multiple Parallel Coordinates Plots of ICT Variables by Cluster") +
  facet_grid(~ CLUSTER) + 
  theme(axis.text.x = element_text(angle = 30))
```

The parallel coordinate plot above reveals that households in Cluster 4 townships tend to own the highest number of TV and mobile-phone. On the other hand, households in Cluster 5 tends to own the lowest of all the five ICT.

Note that the `scale` argument of `ggparcoor()` provide several methods to scale the clustering variables. They are:

-   std: univariately, subtract mean and divide by standard deviation.

-   robust: univariately, subtract median and divide by median absolute deviation.

-   uniminmax: univariately, scale so the minimum of the variable is zero, and the maximum is one.

-   globalminmax: no scaling is done; the range of the graphs is defined by the global minimum and the global maximum.

-   center: use uniminmax to standardize vertical height, then center each variable at a value specified by the scaleSummary param.

-   centerObs: use uniminmax to standardize vertical height, then center each variable at the value of the observation specified by the centerObsID param

There is no one best scaling method to use. We should explore them and select the one that best meet our analysis need.

Last but not least, we can also compute the summary statistics such as mean, median, sd, etc to complement the visual interpretation.

In the code chunk below, *`group_by()`* and *`summarise()`* of dplyr are used to derive mean values of the clustering variables.

```{r}
shan_sf_ngeo_cluster %>% 
  st_set_geometry(NULL) %>%
  group_by(CLUSTER) %>%
  summarise(mean_RADIO_PR = mean(RADIO_PR),
            mean_TV_PR = mean(TV_PR),
            mean_LLPHONE_PR = mean(LLPHONE_PR),
            mean_MPHONE_PR = mean(MPHONE_PR),
            mean_COMPUTER_PR = mean(COMPUTER_PR))
```
